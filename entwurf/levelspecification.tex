
\chapter{Level JSON Format Beschreibung}
\section{Präambel}
Die Auslieferung von Levels des Spiels wird auf Basis des verbreiteten JSON (JavaScript Object Notation) Formates und mittels Konventionen auf der Dateisystemhierarchie geschehen.
Die Gründe für die Verwendung von JSON sind
\begin{enumerate}[a)]
	\item Einfache Schreib- und Editierbarkeit
	\item Gute Les- und Nachvollziehbarkeit
	\item Geringerer Overhead gegenüber XML
	\item Unterstützung von Haus aus durch LibGDX
	\item Gute Austausch- und Erweiterbarkeit gegenüber datenbank- oder codebasierten Herangehensweisen
\end{enumerate}
Dafür ist es zunächst jedoch erforderlich, dass die Struktur der letztendlich für den Aufbau eines Levels benötigten Daten, detailliert spezifiziert ist.
Im folgenden werden die einzelnen Attribute eines Levels und ihre Bedeutungen, sowie ihre Repräsentation in JSON beschrieben.

\section{Grundlegendes}
Im Folgenden wird stets davon ausgegangen, dass sich jegliche Dateisystem Pfadangaben relativ zu /assets beziehen, wobei als Wurzelverzeichnis das Android Projektverzeichnis angesehen wird.
Die Nutzung des asset Ordners wird hierbei von libGDX vorgegeben.
Vergleiche hierzu den Entsprechenden Artikel der Dokumentation \footnote{\url{https://github.com/libgdx/libgdx/wiki/File-handling\#android}}.
Zudem sei erwähnt, dass sich alle in JSON angegebenen Elemente, die von der Anwendung benutzt werden, im Namespace "`de.croggle"' befinden.
Das heißt, dass sich in dem Wurzelobjekt jeder JSON Datei ein Objekt mit diesem Namen befindet.
Dies macht es sicherer, gegebenenfalls in Zukunft vom Nutzer angegebene Levels zu laden, auch wenn dies derzeit nicht als Funktion vorgesehen ist.
\begin{lstlisting}[language=json,caption={Standardinhalt jeder JSON Datei der Anwendung}]
{
	"de.croggle" : {
		...
	}
}
\end{lstlisting}

Da die Beschreibungen von Levels, ähnlich wie Quellcode, komplexe Sachverhalte im Lambda Kalkül abbilden können, deren Wirkungsweise nicht direkt ersichtlich sein kann,
sieht die Spezifikation der JSON Repräsentation Kommentarattribute vor.
Diese können und sollen verwendet werden, um besonders schwer nachzuvollziehende Stellen zu dokumentieren, aber auch, um einfach auf die Ideen und Zielsetzungen innerhalb eines bestimmten Levels hinzuweisen.
Solche Kommentarattribute werden durch das Präfix "`\_comment"' markiert und eingeleitet.
Attributsnamen, die mit diesem beginnen sind dementsprechend reserviert.
Es muss zudem davon ausgegangen werden, dass sich an einer späteren Stelle der Entwicklung ein Mechanismus im Build System befindet, der die Kommentare vor der Auslieferung aus den JSON Dateien entfernt.

Da die Kommentare jeweils durch eine Zeichenkette im Namen eines Attributes eingeleitet werden und JSON keine Namen von Attributen in Listen (eingeleitet durch "`["') vorsieht, sind Kommentare nur in Objekten (eingeleitet durch "`\{"') zulässig.
Dies ist insofern keine Einschränkung, da Listen im Allgemeinen nur anonyme Instanzen von Elementen beinhalten, deren es für gewöhnlich keinerlei weitere Erklärungen bedarf.
Der Wert eines solchen Kommentarattributes kann einerseits aus einem einfachen Stringliteral (Zeichenkette) bestehen, wenn es sich um kurze, einzeilige Kommentare handelt.
Andererseits kann bei längeren Kommentaren auch eine Liste von Stringliteralen angegeben werden, wobei jedes Element auf eine neue Zeile geschrieben wird.
Damit wird der Einschränkung im JSON Format Rechnung getragen, dass es keine Möglichkeit gibt, sogenannte Multiline Strings anzugeben.
Zuletzt ermöglicht die Spezifikation auch mehrere Kommentarattribute innerhalb des gleichen Objektes.
Dafür wird den jeweiligen "`\_comment"'-Attributnamen noch jeweils eine Ziffernfolge angehängt, welche von null beginnend aufsteigt.
Dies ist nötig, da der JSON Standard keine gleichen Attributnamen innerhalb einunddesselben Objekts vorsieht.
Listing 4.2 verdeutlicht die Anwendung von Kommenatren in JSON Files.
\begin{lstlisting}[language=json,caption={Kommentare in einer JSON Datei}]
{
	"_comment" : "Dies ist ein kurzer Kommentar",
	"de.croggle" : {
		"_comment": [
			"Längere Kommentare, die ",
			"über mehrere Zeilen gehen, ",
			"werden mittels einer Liste repräsentiert"
		]
	},
	"_comment0" : "Mehrere Kommentare in ein und demselben Objekt...",
	"_comment1" : "... werden mittels aufsteigender Nummern als Postfix unterschieden"
}
\end{lstlisting}

\section{Levels}
Bisher sind folgende Leveltypen für das Spiel vorgesehen:
\begin{itemize}
	\item Multiple Choice Levels (MC)
	\item Färben und Einfügen (FE)
	\item Schrittanzahl (SA)
\end{itemize}
Um ein Level zur Laufzeit zu laden, müssen die folgenden Daten zur Verfügung stehen:
\begin{enumerate}[a)]
	\item Das Levelpaket, zu dem ein Level gehört
	\item Die Position des Levels innerhalb eines Levelpakets
	\item Eine Zeichenkette, die auf das Level einstimmt
	\item Eine (optionale) Animation zu Beginn eines Levels
	\item Der Name eines Designthemas (es kann sich auch nur um den Pfad zu einem Hintergrundbild handeln)
	\item Tipps, um das Level abzuschließen
	\item Den Typ eines Levels
	\item Konstellationen (Anfang, Ende, mögliche Antworten)
\end{enumerate}
Zur Angabe dieser Daten existiert zu jedem Level eine JSON Datei (Endung "`.json"'), deren Name der auf zwei Stellen aufgefüllten Identifikationsnummer innerhalb eines Levelpakets entspricht.
Dies ermöglicht das schnelle Auflisten aller Levels eines Pakets, impliziert aber auch, dass ein Levelpaket höchstens 100 Level enthalten kann.
Zur Vermeidung von Namenskollisionen zwischen Levels verschiedener Pakete, erhält jedes Paket sein eigenes Unterverzeichnis.
Dazu jedoch später mehr.
Innerhalb einer solchen JSON Datei existiert (im Applikationsnamensraum) eine Liste mit dem Namen "Levels".
An dieser Stelle wäre auch ein einfaches Objekt möglich, welches direkt alle notwendigen Daten enthält.
Der gewählte Ansatz bietet allerdings die Vorteile, dass erstens direkt auf die Levels als solche zugegriffen werden kann, da keine Typprüfung stattfinden muss ("`Levels"' darf nur Levels enthalten).
Zweitens lassen sich gegebenenfalls alle Levels einfach in dieser einfachen Liste zusammenlegen, was nur noch eine JSON Datei notwendig machen und somit Spielraum für Leistungsverbesserungen bieten würde.
Und drittens muss kein Name für die sonst eigentlich anonymen Levels angegeben werden.


Innerhalb dieses Grundgerüstes werden alle weiteren, notwendigen Daten spezifiziert.
Zuerst genannt sei hierbei die Beschreibung: Unter dem Attributsnamen "`description"' wird hierbei die auf das Level einstimmende Zeichenkette abgelegt.
Unter dem Attribut "`design"' ist, wie erwähnt, entweder der Name eines Designthemas oder der Name/Pfad zu einem alternativen Hintergrundbild in einer Zeichenkette gespeichert.
Bei einer leeren Zeichenkette wird das Standardthema des Levelpakets verwendet.
Das Attribut "`hints"' bezeichnet eine Liste von Zeichenketten, die in der Reihenfolge aufgedeckt werden, wie sie in der Liste vorkommen.
Die Liste an sich kann allerdings auch leer bleiben.

Unter dem Namen "`type"' muss eine Zeichenkette existieren, die einen der folgenden Werte enthalten muss:
\begin{itemize}
	\item multiple choice
	\item transform
	\item step count
\end{itemize}

Für jeden dieser Typen unterscheidet sich der Inhalt des letzten Attributs, dem "`data"' Attribut.
Dieses enthält die für die einzelnen Typen unterschiedlichen Daten.
Diese werden im Folgenden spezifiziert.
Listing 4.3 beschreibt das benötigte Rahmenwerk für alle Levels.
\begin{lstlisting}[language=json,caption={JSON Leveldatei, z.B. json/00/00.json}]
{
	"de.croggle" : {
		"levels" : [
			{
				"type" : "...",
				"description" : "...",
				"design" : "...",
				"hints" : [
					...
				],
				"data" : {
					...
				}
			}
		]
	}
}
\end{lstlisting}

\subsection{Darstellung von Lambda Ausdrücken}
Alle Leveltypen haben gemein, dass sie an mindestens einer Stelle ein Spielfeld mit einem Alligatorausdruck anzeigen.
Daher wird zunächst auf die Darstellung eines solchen Spielfelds mit der sich darauf befindlichen Konstellation (dem Lambdaterm) in der JSON Levelbeschreibung eingegangen.
Diese Darstellung bildet das zu den Lambdatermen gehörige Klassenmodell transparent ab.


Das heißt, dass Spielfelder (im Folgenden auch Boards genannt) eine Liste von Elementen, genauer gesagt von BoardObjects, als Attribut besitzen.
Von diesen BoardObjects existieren drei Typen, nämlich Ei, farbiger Alligator und alter Alligator.
Alle diese drei Objekttypen verfügen über eine Zeichenkette mit Namen "`type"', die die Werte
\begin{itemize}
	\item egg
	\item colored alligator
	\item aged alligator
\end{itemize}
annehmen darf.
Aus dieser wird der genaue Typ eines BoardObjects abgeleitet, aus dem die weiteren Attribute hervorgehen.
Diese sind im Folgenden beschrieben.

\subsubsection{Eier}
Objekte vom Typ "`Egg"' besitzen die folgenden Eigenschaften:
\begin{itemize}
	\item[color:] Eine Ganzzahl, die einer Farbe zugeordnet wird. Der Wert befindet sich zwischen 0 und 30.
\end{itemize}

\subsubsection{Farbige Alligatoren}
Objekte vom Typ "`colored alligator"' besitzen die folgenden Eigenschaften:
\begin{itemize}
	\item[color:] Eine Ganzzahl, die einer Farbe zugeordnet wird. Der Wert befindet sich zwischen 0 und 30.
	\item[children:] Eine Liste von weiteren BoardObjects
\end{itemize}

\subsubsection{Alte Alligatoren}
Objekte vom Typ "`aged alligator"' besitzen die folgenden Eigenschaften:
\begin{itemize}
	\item[children:] Eine Liste von weiteren BoardObjects
\end{itemize}

\begin{lstlisting}[language=json,caption={Ein einfaches Board mit allen existierenden BoardObjects}]
{
	"families" : [
		{
			"type" : "colored alligator",
			"color" : 0,
			"children" : [
				{
					"type" : "aged alligator",
					"children" : [
						{
							"type" : "egg",
							"color" : 0
						},
						{
							"type" : "egg",
							"color" : 0
						}
					]
				},
				{
					"type" : "egg",
					"color" : 0
				}
			]
		}
	]
}
\end{lstlisting}
	
\begin{figure}[h]
	\caption{Der durch das vorausgehende Listing dargestellte Alligatorausdruck}
	\begin{center}
		\includegraphics[width=0.3\textwidth]{../assets/lx.((x x) x).png}
	\end{center}
\end{figure}

\subsection{"`Multiple Choice"' Leveldaten}

\subsection{"`Färben und Einfügen"' Leveldaten}

\subsection{"`Schrittanzahl"' Leveldaten}

\section{Levelpakete}
Levels werden durch sogenannte Pakete gruppiert.
Diese Pakete besitzen folgende Eigenschaften, die durch die Spezifikation repräsentiert werden müssen:
\begin{enumerate}[a)]
	\item Einen Namen zur Bezeichnung des Pakets
	\item Eine Grafik, die zum Thema des Pakets passt
	\item Eine Position des Pakets, um die Reihenfolge der Pakete festzulegen
	\item Abhängigkeiten, die zum Freischalten der Box erfüllt sein müssen
	\item Eine Verbindung zwischen dem Paket und den dazugehörigen Leveln (kann allerdings auch nur im Level angegeben sein)
	\item Eine Angabe zu etwaigen Story Animationen, die beim ersten Spielen des Pakets gezeigt wird.
\end{enumerate}
Hierbei muss jedoch nicht allein auf JSON zurückgegriffen werden.
Auch Dateisysteminformationen können berücksichtigt werden.
Allerdings muss bedacht werden, dass durch Festlegung von Konventionen keine zu starke Einschränkung passiert, sodass die Erweiterbarkeit nicht eingeschränkt wird.

Zuerst einmal existiert zu jedem Levelpaket 
