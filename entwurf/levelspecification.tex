
\chapter{Level JSON Format Beschreibung}
\section{Präambel}
Die Auslieferung von Levels des Spiels wird auf Basis des verbreiteten JSON (JavaScript Object Notation) Formates und mittels Konventionen auf der Dateisystemhierarchie geschehen.
Die Gründe für die Verwendung von JSON sind
\begin{enumerate}[a)]
	\item Einfache Schreib- und Editierbarkeit
	\item Gute Les- und Nachvollziehbarkeit
	\item Geringerer Overhead gegenüber XML
	\item Unterstützung von Haus aus durch LibGDX
	\item Gute Austausch- und Erweiterbarkeit gegenüber datenbank- oder codebasierten Herangehensweisen
\end{enumerate}
Dafür ist es zunächst jedoch erforderlich, dass die Struktur der letztendlich für den Aufbau eines Levels benötigten Daten, detailliert spezifiziert ist.
Im folgenden werden die einzelnen Attribute eines Levels und ihre Bedeutungen, sowie ihre Repräsentation in JSON beschrieben.

\section{Grundlegendes}
Im Folgenden wird stets davon ausgegangen, dass sich jegliche Dateisystem Pfadangaben relativ zu /assets beziehen, wobei als Wurzelverzeichnis das Android Projektverzeichnis angesehen wird.
Die Nutzung des asset Ordners wird hierbei von libGDX vorgegeben.
Vergleiche hierzu https://github.com/libgdx/libgdx/wiki/File-handling\#android.
Zudem sei erwähnt, dass sich alle in JSON angegebenen Elemente, die von der Anwendung benutzt werden, im Namespace "`de.croggle"' befinden.
Das heißt, dass sich in dem Wurzelobjekt jeder JSON Datei ein Objekt mit diesem Namen befindet.
Dies macht es sicherer, gegebenenfalls in Zukunft vom Nutzer angegebene Levels zu laden, auch wenn dies derzeit nicht als Funktion vorgesehen ist.
\begin{lstlisting}[language=json,caption={Standardinhalt jeder JSON Datei der Anwendung}]
{
	"de.croggle" : {
		...
	}
}
\end{lstlisting}

Da die Beschreibungen von Levels, ähnlich wie Quellcode, komplexe Sachverhalte im Lambda Kalkül abbilden können, deren Wirkungsweise nicht direkt ersichtlich sein kann,
sieht die Spezifikation der JSON Repräsentation Kommentarattribute vor.
Diese können und sollen verwendet werden, um besonders schwer nachzuvollziehende Stellen zu dokumentieren, aber auch, um einfach auf die Ideen und Zielsetzungen innerhalb eines bestimmten Levels hinzuweisen.
Solche Kommentarattribute werden durch das Präfix "`\_comment"' markiert und eingeleitet.
Attributsnamen, die mit diesem beginnen sind dementsprechend reserviert.
Es muss zudem davon ausgegangen werden, dass sich an einer späteren Stelle der Entwicklung ein Mechanismus im Build System befindet, der die Kommentare vor der Auslieferung aus den JSON Dateien entfernt.

Da die Kommentare jeweils durch eine Zeichenkette im Namen eines Attributes eingeleitet werden und JSON keine Namen von Attributen in Listen (eingeleitet durch "`["') vorsieht, sind Kommentare nur in Objekten (eingeleitet durch "`\{"') zulässig.
Dies ist insofern keine Einschränkung, da Listen im Allgemeinen nur anonyme Instanzen von Elementen beinhalten, deren es für gewöhnlich keinerlei weitere Erklärungen bedarf.
Der Wert eines solchen Kommentarattributes kann einerseits aus einem einfachen Stringliteral (Zeichenkette) bestehen, wenn es sich um kurze, einzeilige Kommentare handelt.
Andererseits kann bei längeren Kommentaren auch eine Liste von Stringliteralen angegeben werden, wobei jedes Element auf eine neue Zeile geschrieben wird.
Damit wird der Einschränkung im JSON Format Rechnung getragen, dass es keine Möglichkeit gibt, sogenannte Multiline Strings anzugeben.
Zuletzt ermöglicht die Spezifikation auch mehrere Kommentarattribute innerhalb des gleichen Objektes.
Dafür wird den jeweiligen "`\_comment"'-Attributnamen noch jeweils eine Ziffernfolge angehängt, welche von null beginnend aufsteigt.
Dies ist nötig, da der JSON Standard keine gleichen Attributnamen innerhalb einunddesselben Objekts vorsieht.
Listing 4.2 verdeutlicht die Anwendung von Kommenatren in JSON Files.
\begin{lstlisting}[language=json,caption={Kommentare in einer JSON Datei}]
{
	"_comment" : "Dies ist ein kurzer Kommentar",
	"de.croggle" : {
		"_comment": [
			"Längere Kommentare, die ",
			"über mehrere Zeilen gehen, ",
			"werden mittels einer Liste repräsentiert"
		]
	},
	"_comment0" : "Mehrere Kommentare in ein und demselben Objekt...",
	"_comment1" : "... werden mittels aufsteigender Nummern als Postfix unterschieden"
}
\end{lstlisting}

\section{Levels}
Bisher sind folgende Leveltypen für das Spiel vorgesehen:
\begin{itemize}
	\item Multiple Choice Levels (MC)
	\item Färben und Einfügen (FE)
	\item Schrittanzahl (SA)
\end{itemize}
Um ein Level zur Laufzeit zu laden, müssen die folgenden Daten zur Verfügung stehen:
\begin{enumerate}[a)]
	\item Das Levelpaket, zu dem ein Level gehört
	\item Die Position des Levels innerhalb eines Levelpakets
	\item Eine Zeichenkette, die auf das Level einstimmt
	\item Tipps, um das Level abzuschließen
	\item Den Typ eines Levels
	\item Konstellationen (Anfang, Ende, mögliche Antworten)
\end{enumerate}
Zur Angabe dieser Daten existiert zu jedem Level eine JSON Datei (Endung "`.json"'), deren Name der auf zwei Stellen aufgefüllten Identifikationsnummer innerhalb eines Levelpakets entspricht.
Dies ermöglicht das schnelle Auflisten aller Levels eines Pakets, impliziert aber auch, dass ein Levelpaket höchstens 100 Level enthalten kann.
Zur Vermeidung von Namenskollisionen zwischen Levels verschiedener Pakete, erhält jedes Paket sein eigenes Unterverzeichnis.
Dazu jedoch später mehr.
Innerhalb einer solchen JSON Datei existiert (im Applikationsnamensraum) eine Liste mit dem Namen "Levels".
An dieser Stelle wäre auch ein einfaches Objekt möglich, welches direkt alle notwendigen Daten enthält.
Der gewählte Ansatz bietet allerdings die Vorteile, dass erstens direkt auf die Levels als solche zugegriffen werden kann, da keine Typprüfung stattfinden muss ("`Levels"' darf nur Levels enthalten).
Zweitens lassen sich gegebenenfalls alle Levels einfach in dieser einfachen Liste zusammenlegen, was nur noch eine JSON Datei notwendig machen und somit Spielraum für Leistungsverbesserungen bieten würde.
Und drittens muss kein Name für die sonst eigentlich anonymen Levels angegeben werden.
Listing 4.3 beschreibt das benötigte Rahmenwerk für alle Leveldateien.
\begin{lstlisting}[language=json,caption={JSON Leveldatei, z.B. json/00/00.json}]
{
	"de.croggle" : {
		"levels" : [
			{
				"_comment": "Hier beginnt die eigentliche Levelbeschreibung von Levelpaket 1/ Level 1"
			}
		]
	}
}
\end{lstlisting}

\section{Levelpakete}
Levels werden durch sogenannte Pakete gruppiert.
Diese Pakete besitzen folgende Eigenschaften, die durch die Spezifikation repräsentiert werden müssen:
\begin{enumerate}[a)]
	\item Einen Namen zur Bezeichnung des Pakets
	\item Eine Grafik, die zum Thema des Pakets passt
	\item Eine Position des Pakets, um die Reihenfolge der Pakete festzulegen
	\item Abhängigkeiten, die zum Freischalten der Box erfüllt sein müssen
	\item Eine Verbindung zwischen dem Paket und den dazugehörigen Leveln (kann allerdings auch nur im Level angegeben sein)
	\item Eine Angabe zu etwaigen Story Animationen, die beim ersten Spielen des Pakets gezeigt wird.
\end{enumerate}
Hierbei muss jedoch nicht allein auf JSON zurückgegriffen werden.
Auch Dateisysteminformationen können berücksichtigt werden.
Allerdings muss bedacht werden, dass durch Festlegung von Konventionen keine zu starke Einschränkung passiert, sodass die Erweiterbarkeit nicht eingeschränkt wird.

Zuerst einmal existiert zu jedem Levelpaket 
